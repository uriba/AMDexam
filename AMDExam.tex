\documentclass[a4page,notitlepage]{article}
\usepackage{color,soul,amsmath,graphicx}
\usepackage[outercaption]{sidecap}
\usepackage[citestyle=authoryear]{biblatex}
\usepackage[font=small,labelfont=bf]{caption}
\sidecaptionvpos{figure}{c} \providecommand{\abs}[1]{\lvert#1\rvert}
\providecommand{\norm}[1]{\lVert#1\rVert}

\title{Algorithmic Mechanism Design, final exam} \author{Uri
  Barenholz} \date{Febuary 2014}

\begin{document}
\maketitle
\section{Answers}
\begin{enumerate}
\item We start by noting that the expected revenue of OPT is the sum
  of the expected revenue of all of the players, that is:
  \[
  \text{OPT}(S)=\sum_{j=1}^{|S|}E[\text{Revenue}_j]=\sum_{j=1}^{|S|}E[\phi_j(v_j)x_j(\vec{v})]
  \]
  (Where the last equality uses Mayerson's theorem)
\item
  \begin{enumerate}
  \item The algorithm will work as follows, to generate a maximal
    dense allocation do:
    \begin{enumerate}
    \item For each player calculate his density, $d_i=\frac{v_i(s_i)}{s_i}$, requiring $O(n,\log(h),\log(m))$.
    \item Sort the calculated densities in descending order requiring $O(n\log(n))$.
      For players with identical densities, sort them internally by increasing demand.
    \item Iterate on the sorted list, fulfiling the requirement for
      each player (allocating $s_i$ items to the $i$'th player on the sorted list), until reaching the point where not enough items
      remain to fulfil the requirement of the next player, requiring $O(n,\log(m),\log(h))$.
    \end{enumerate}
    This algorithm generates a dense allocation as each player that receives items receivs the exact number of items he is interested in, and he only receives these items if all players with higher density already had their demand satisfied.

    The allocation is \textit{maximum density} as all items (up to the demand of the next-highest density player's demand) have been allocated.
Therefore, every other dense allocation must satisfy the demand for all players up to the last player who's demand was satisfied and therefore does not have enough items left to satisfy the demand of another player in such a way that will not violate the dense requirement.
The special case of being able to satisfy the demand of another player that has identical density to the highest unfulfilled one but with a lower demand is also impossible as the sorted list internally sorted players with identical densities according to their (ascending) demands.

    To generate the welfare maximizing allocation assigning all items to a single player, calculate the welfare generated by assigning all the items to every possible player ($O(n,\log(h))$) and assign all items to the player generating the highest welfare.
    
    Finally, select the highest revenue generating alternative out of
    these two possibilities.
    \item
      Let's observe the maximum density solution generated by the algorithm.
      If it's revenue is more than half of the optimal revenue, we're done.
      
      Otherwise we note that it's revenue is (when the indices are sorted according to the densities): $\sum_{i=1}^kd_is_i<\frac{\text{OPT}}{2}$ (where $k$ is the number of players it was able to satisfy the demand of).
      We now observe the revenue the optimal algorithm (OPT) generates from players ${1,\cdots,k}$ vs. the revenue it generates from the rest of the players.
      Clearly, if most of the optimal revenue is generated by the first $k$ players than the maximum density (which satisfies all of them) generates more than half the revenue of OPT.
      Otherwise, as all the other players have densities smaller than or equal to $d_{k+1}$ whereas all players in the group ${1,\cdots,k}$ have densities higher than or equal to $d_k$, it follows that if more than half the items can be allocated to the group ${1,\cdots,k}$, then that would generate a revenue higher than half of OPT.
      We therefore deduce that the maximum density allocation terminated while having at least half the items still unallocated.
      But that in turn means that $s_{k+1}\geq\frac{m}{2}$.
      Finally, we claim that therefore, allocating all the items to player $k+1$ will generate a revenue higher than half the optimal revenue.
      This is due to the following reason:
      \item
      If player $i$ received $s_i$ the items with $v_i$, then he either received all of the items under the algorithm, or he was one of the $k$ players with the highest densities, whos demand was satisfied by the maximum density allocation.
      If he was one of the $k$ players in the maximum density allocation whos demand was satisfied, then increasing his value only increases his density, and thus the algorithm will still allocate $s_i$ items to him (nothing that this will give superior result than allocating all items to this player as other players will also generate positive revenue in this case).
      If he was given all of the items, then increasing his value will increase the value of this option for the algoritm and may also make him (due to his increased density) a participant in the possible maximum density allocation solution.
      In either case he will still be allocated at least $s_i$ items.
      Explicitly, increasing his value may not cause the algorithm to prefer allocating all items via maximum density to players that do not include him as that would generate the same revenue as when his value was $v_i$, and in that case the algorithm prefered allocating all the items to him.
      
      Thus, to conclude, by the revelation principle, there is a payment function that makes this mechanism truthful.
      \item
        First we note that declaring a \emph{smaller} value of $s_i'<s_i$ increases the valuation (as for all allocations smaller than $s_i'$ the value remains 0, for all allocation larger than $s_i$ the value remains $v_i$ and for all intermediate allocations the value increases from 0 to $v_i$.

        Next we note that decreasing $s_i$ maintains the algorithm's monotonicity as it increases the density and maintains the value of allocating all the items to this player.
        Therefore, if all items were allocated to this player via the algoritm with $s_i$, then decreasin $s_i$ will not cause the algorithm to prefer a maximum density solution that does not include this player (which will have the same value as the maximum density solution with $s_i$) instead of allocating all items to him.
        Thus, in this case, the algorithm will either allocate all items to this player, of satisfy his demand via a maximum density allocation that includes him.

        In case this player's demand was satisfied via a maximum density allocation, increasing his density will only move him 'up' the line in the allocation (not changing his generated revenue, but possibly allowing the demand of more players to be satisfied, thus increasing the revenue generated by the maximum density allocation) and thus, in this case, his demand will still be satisfied by the algorithm.
        
        To conclude, the algorithm is monotone also w.r.t. $s_i$ and therefore a truthful mechanism exists.
        Using VCG will therefore result in a payment function that will make both scenarios truthful.
  \end{enumerate}
  \item
    \begin{enumerate}
    \item 
      Let $p(v_i)$ be the payment of player $i$ when stating $v_i$ and receiving slot $j$ with rate $r_j$.
      As the mechanism is truthful, bidding a higher value, $v_i'>v_i$, and receiving a (possibly) different slot $j'$ with rate $r_{j'}$ will result in a lower or equal profit to this player:
      \begin{equation*}
        v_ir_j-p(v_i)\geq v_ir_{j'}-p(v_i')\ \rightarrow v_i(r_j-r_{j'})\geq p(v_i)-p(v_i')
      \end{equation*}
      On the other hand, stating $v_i$ when his true value is $v_i'>v_i$ will also not increase his profit, so:
      \begin{equation*}
        v_i'r_{j'}-p(v_i')\geq v_i'r_j-p(v_i)\ \rightarrow v_i'(r_{j'}-r_j)\geq p(v_i')-p(v_i)\ \rightarrow \ v_i'(r_j-r_{j'})\leq p(v_i)-p(v_i')
      \end{equation*}
      Combining the two we get that:
      \begin{equation*}
        v_i(r_j-r_{j'})\geq p(v_i)-p(v_i')\geq v_i'(r_j-r_{j'})\ \rightarrow \ v_i(r_j-r_{j'})\geq v_i'(r_j-r_{j'})
      \end{equation*}
      As $v_i < v_i'$ we conclude that $r_j-r_{j'}\leq 0$ implying that $j'\leq j$.
    \item
      Following the hint (and the monotonicity, which we've proved in the previous item) we claim that the player with the highest value gets the first slot (and in general, if we sort the players by their values, then this is the order in which they get the slots).
      We prove this by induction.

      Induction base: assume by contradiction that the player which is assigned the first slot (noting that, by completeness, some player must be assigned the first slot), player $i$, has value $v_i$, but that there exists another player, $i'$, with a higher value $v_{i'}>v_i$, that is assigned a higher slot.
      Now observe what happens when player $i$ increases his value to $v_{i'}$, while all the other players maintain their values.
      By the monotonicity, he will be assigned a slot smaller than or equal to the slot he was previously assigned, the first slot, so he must still be allocated the first slot.
      So when the values are the same as the initial values, but with player $i$ having a value of $v_{i'}$, he is still assigned the first slot, and player $i'$ is assigned some higher slot.
      But now, if we start from this state and look at what happens when player $i'$ reduces his value to $v_i$, we get at a contradiction:
      By the monotonicity principle, player $i'$ should (after the reduction) be assigned a slot larger than or equal to the slot he was previously assigned (which was higher than the first slot) so he is assigned a slot higher than the first slot; on the other hand, as the algorithm is anonymous, and as the new valuation (with $i$ having a value of $v_{i'}$ and $i'$ having a value of $v_i$) is a permutation of the original valuation switching players $i$ and $i'$, player $i'$ should be assigned the first slot.

      Induction step:
      Assume that the $k$ players with highest values are assigned the first $k$ slots, we show that the $k+1$ slot is assigned to the player with the $k+1$ highest value.
      Assume, again, by contradiction, that this is not the case, i.e. that player $i$, with value $v_i$ is assigned the $k+1$ slot (using completeness again to claim that that slot must be assigned to some player), but that there is some other player $i'$ whose value is higher than that of player $i$ (but still lower than the values of the $k$ highest players) which is assigned a higher slot than $k+1$.
      We can now follow the same logic that was performed in the induction base to get at a contradiction.
      Look at the allocation resulting when player $i$ increases his value to $v_{i'}$.
      By monotonicity he must now be allocated a slot lower than or equal to the $k+1$'th slot.
      As the first $k$ slots are occupied by the players with the $k$ highest values, by the induction assumption, and recalling that $v_{i'}$ is lower than all of these values, $i$ must still be allocated the $k+1$ slot, and therefore $i'$ must be allocated a higher slot than $k+1$.
      Now reduce the value of player $i'$ from $v_{i'}$ to $v_i$.
      By monotonicity he must now be allocated a slot higher than or equal to the slot he was previously allocated, so he must be allocated a slot higher than $k+1$, which contradicts the anonymity of the algorithm (that should have now allocated the $k+1$ slot to $i'$.
      
      To conclude - we've shown that any truthful, anonymous, complete mechanism (and we note that VCG is such a mechanism) must allocate the slots to the players in a descending order (so that the player with the highest value gets the smallest slot etc.).
      Therefore, all such mechanisms (including VCG) result in the same allocation.
    \end{enumerate}
\end{enumerate}
\end{document}

